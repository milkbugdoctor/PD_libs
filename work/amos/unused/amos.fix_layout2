#!/bin/env activeperl

use Carp;
use Time::HiRes qw ( time alarm sleep );
use Fasta;

# read
use enum qw(START END ID R_SCORE R_TRIM1 R_TRIM2 STRAND ALIGN R_ARRAY);
# clump/haplotype
use enum qw(H_START H_END H_STR H_HASH);
# node
use enum qw(N_START N_END N_STR N_READ);

use strict vars;

my $debug = 2;

my $overlap_percent = 90;
my $big_block = 10000; # size for graphs
my $small_block = 1000; # size for adding edges to graph

my $big_num = 10e12;
my $patch = 100;
my $allow = 1;
my $min_overlap = 10;
my $big_overlap = 200;		# overlap needed by 454 contig pieces
my $contig_overlap = 200;	# for merging overlapping reads/contigs that end abruptly
my $min_contig = 200;
my $min_fragment = 20;		# minimum size of read fragment
my $max_gap = 5;
my $max_igap = 5;
my $no_delete = 0;
my $min_score = 0;

use Getopt::Std;
getopts('bc:C:d:f:g:i:m:no:O:p:rs:z:');

our ($opt_b, $opt_c, $opt_C, $opt_d, $opt_f, $opt_g, $opt_i, $opt_m, $opt_n);
our ($opt_o, $opt_O, $opt_p, $opt_r, $opt_s, $opt_z);

@ARGV == 3 || die "\nUsage: $0 [options] file.layout reference.fa reads.fa > new.layout

    This is a new version of amos.fix_layout that was never finished.
    The Java program Cheater replaced them both.

    -m map	    use read map to identify split contigs used as reads
    -b		    break contig if necessary (used with -d)
    -d diff	    maximum allowed difference from best
    -n		    no delete: cancel -d
    -p patch	    patch size (default $patch)
    -r		    remove extra stuff so make-consensus won't choke

    -o min	    minimum overlap between reads (default $min_overlap)
    -C min	    minimum overlap for contigs to be merged (default $contig_overlap)
    -O min	    minimum overlap between 454 contig pieces (default $big_overlap)

    -c len	    minimum contig length (default $min_contig)
    -g gap	    maximum internal or external gap allowed (default $max_gap)
    -i gap	    maximum internal gap allowed (default $max_igap)
    -s score	    minimum alignment score

    -z file	    output all reads in AMOS CTG format before building contigs

";

$allow = $opt_d if $opt_d ne '';
$patch = $opt_p if $opt_p ne '';
$min_overlap = $opt_o if $opt_o ne '';
$big_overlap = $opt_O if $opt_O ne '';
$contig_overlap = $opt_C if $opt_C ne '';
$max_igap = $max_gap = $opt_g if $opt_g ne '';
$max_igap = $opt_i if $opt_i ne '';
$min_score = $opt_s if $opt_s ne '';
$min_contig = $opt_c if $opt_c ne '';
if ($opt_n ne '') {
    $no_delete = 1;
    undef $opt_d;
}

require 'markers.pl';
require 'ranges.pl';
require 'misc.pl';
require 'primers.pl';
require 'amos.pl';
require 'fasta.pl';

my $layout = shift;
my $reference_file = shift;
my $reads_fa = shift;

warn "opening reference from $reference_file\n";
my $ref_fasta = Fasta::new($reference_file);

warn "reading in read sequences from $reads_fa\n";
my $fasta = Fasta::new($reads_fa);
$fasta->get_seq_positions(1); warn "done reading\n";

my $num_contigs;

our $contig_hash;
if ($opt_m) {
    my $mapfile = $opt_m;
    $contig_hash = get_contig_hash($mapfile);
}

open(INFILE, $layout) or die "$layout: $!";
while (<INFILE>) {
    chomp;
    next if (! /^C (\d+)\t(\d+)\t(\S+)\t(\S+)/);
    our @reads = ();
    my ($contig, $reads, $ref, $pos) = ($1, $2, $3, $4);
    $pos =~ /(-?\d+)-(-?\d+)/;
    my ($contig_start, $contig_end) = ($1, $2);
    warn "\nreading $ref contig $contig $contig_start-$contig_end\n";
    for my $i (1 .. $reads) {
	chomp(my $line = <INFILE>);
	if ($line =~ /^\s*$/) {
	    printf STDERR "got %d reads but expected %d!\n", scalar @reads, $reads;
	    last;
	}
        my ($id, $start, $end, $trim1, $trim2, $score, $seq) = split /\s/, $line, 7;
	confess "bad read $line" if $id eq '' or $start eq '';
	my $strand = '+';
	if ($start > $end) {
	    $strand = '-';
	    ($start, $end) = ($end, $start);
	}
	my @marker = ($start, $end, $id, $score, $trim1, $trim2, $strand, $seq);
	push(@reads, \@marker);
    }

    remove_low_scores(\@reads);
    my $layout_contig = LayoutContig::build($ref, $ref_fasta, $contig, $contig_start, $contig_end, \@reads, $fasta);
    if ($opt_z) {
	my $contig = Contig::build($layout_contig);
	open(FILE, ">$opt_z") or die "can't create file [$opt_z]: $!";
	$contig->print(FILE);
	close FILE;
    }

    my @contigs = get_contigs($ref, $contig_start, $contig_end, \@reads);
exit;

    my @new_contigs;
    while (my $contig = pop @contigs) {
	my ($ref, $contig_start, $contig_end, $reads) = @$contig;
	warn "\nremoving low scores 2: $ref $contig_start-$contig_end\n";
# remove_low_scores_2($ref, $contig_start, $contig_end, $reads);
# my @contigs = get_contigs($ref, $contig_start, $contig_end, $reads);
	my @contigs = fix_it($ref, $contig_start, $contig_end, $reads, 1);
	die "contig was split!" if @contigs > 1;
	$contig = $contigs[0];
	my ($new_ref, $cs, $ce) = @$contig;
	die "contig changed size! [$contig_start $contig_end] to [$cs $ce]" if $cs != $contig_start or $ce != $contig_end;
	push(@new_contigs, $contig);
    }
    @contigs = splice(@new_contigs, 0);
    while (my $contig = pop @contigs) {
	if ($opt_d ne '') {
	    my ($ref, $contig_start, $contig_end, $reads) = @$contig;
	    warn "\nremoving worst reads for contig $ref $contig_start-$contig_end\n";
	    my @contigs = fix_it(@$contig, 2);
	    undef $reads;
	    for my $contig (@contigs) {
		print_contig(@$contig);
	    }
	    undef @contigs;
	}
	else {
	    print_contig(@$contig);
	}
	undef $contig;
    }
}

sub remove_low_scores {
    my ($reads) = @_;
    printf STDERR "    remove_low_scores(): starting with %d reads\n", scalar @$reads if $debug;
    my $did_something = 0;
    for (my $i = 0; $i <= $#{$reads}; $i++) {
	my ($start, $end, $id, $score, $trim1, $trim2, $strand, $seq) = @{$reads->[$i]};
	my $len = $end - $start + 1;
	if ($score < $min_score or $len < $min_fragment) {
	    warn "        removing id $id [$start-$end] [trim $trim1 $trim2] score $score\n" if $debug >= 3;
	    splice(@$reads, $i, 1);
	    $did_something = 1;
	    $i--;
	}
	else {
	    warn "        keeping id $id [$start-$end] [trim $trim1 $trim2] score $score\n" if $debug >= 3;
	}
    }
    printf STDERR "    ending with %d reads\n", scalar @$reads if $debug;
    return $did_something;
}

##############################################################################
#
#   Find contigs by traversing reads.  Trimmed reads can only appear at the
#   end of contigs.
#
##############################################################################

sub get_contigs {
    my ($ref, $contig_start, $contig_end, $reads) = @_;

    warn "\nget_contigs $ref $contig_start-$contig_end\n";
    printf STDERR "    starting with %d reads\n", scalar @$reads if $debug;

    #
    # add read markers so we know where they are and which overlap
    #
    printf STDERR "    adding %d reads to index\n", scalar @$reads if $debug;
    my $m = markers::new(700);
    my $index = 0;
    my ($real_start, $real_end);
    my $start = time;
    for my $read (@$reads) {
        my ($start, $end) = @$read;
	$real_end = $end if $real_end eq '' or $real_end < $end;
	$real_start = $start if $real_start eq '' or $real_start > $start;
	my $new_index = $m->add_marker('contig', "+", $start, $end); # only store position
	die "index mismatch" if $index != $new_index;
	$index++;
    }
    printf STDERR "    done adding reads to index in %d seconds\n", time - $start if $debug;

    #
    # build and traverse graphs for small sections
    #
    my @contigs;
    my $contig_len = $real_end - $real_start + 1;
    my @range;
    my ($add_time, $traverse_time);
    for (my $i = $real_start; $i < $real_end; $i += $big_block - 1000) {
	my $block_start = $i;
	my $block_end = $i + $big_block - 1;
	warn "doing $block_start - $block_end\n" if $debug;
	my $graph = {};
	printf STDERR "    adding reads to graph\n" if $debug; $start = time;
	for (my $j = $block_start; $j < $block_end; $j += $small_block) {
	    my ($start, $end) = ($j, $j + $small_block - 1);
	    my @indexes = $m->get_covering_marker_indexes(1, 'contig', "+", $start, $end);
	    next if @indexes == 0;
	    my $tmp = time;
	    printf STDERR "        $start-$end %d reads\n", scalar @indexes; # ZZZ
	    add_to_graph($graph, $reads, @indexes);
	    $add_time += time - $tmp;
	}
	printf STDERR "    add_to_graph time %d seconds\n", $add_time if $debug;
	my %done;
	printf STDERR "    traversing graph\n" if $debug; $start = time;
	# print_graph($graph) if $debug >= 2;
	my $tmp = time;
	traverse2($graph, \%done, 0, keys %{$graph->{nodes}});
	$traverse_time += time - $tmp;
	my @tmp_range = values %done;
	my @haps;
printf STDERR "after traverse got %d nodes with haplotypes\n", scalar @tmp_range;
my $num = 0;
	for my $t (@tmp_range) {
	    for my $s (@$t) {
		push(@haps, $s);
	    }
	}
warn "\nreduce_clumps:\n\n";
	@haps = reduce_clumps(0, @haps);
	print_range4(\@haps) if $debug;

	undef %done;
	printf STDERR "    got %d haplotypes:\n", scalar(@haps) if $debug;
	undef $graph;
	push(@range, @haps);
    }
    printf STDERR "    add_to_graph: $add_time seconds\n";
    printf STDERR "    traverse2: $traverse_time seconds\n";

    # TODO: split haplotypes based on statistics... # FIX
    @range = clumps_to_haplotypes(@range);

    #
    # print
    #

    # warn "\nall ranges\n" if $debug;
    print_haplotypes(\@range) if $debug;
exit;
    @range = reduce_haplotypes(@range);
warn "\nreduced haplotypes\n" if $debug;
    print_haplotypes(\@range) if $debug;
exit;

#    @range = merge_similar_haplotypes($graph, @range);
warn "\nmerged haplotypes\n" if $debug;
    print_range4(\@range) if $debug;
exit; # ZZZ

    for (my $i = 0; $i < $#range; $i += 2) {
        my ($s, $e) = @range[$i, $i + 1];
        my $len = ($e - $s + 1);
        if ($len < $min_contig) {
	    printf STDERR "    removing small contig [$s - $e] size $len\n" if $debug;
            splice(@range, $i, 2);
            $i -= 2;
        }
    }

# warn "    final range\n" if $debug;
#     print_range4(\@range) if $debug;
exit; # ZZZ
    if (@range == 2 and $range[0] == 0 and $range[1] == $contig_end - $contig_start) {
	# don't need to do anything
	warn "    range unchanged, returning\n\n";
	return ([$ref, $contig_start, $contig_end, $reads]);
    }
    return get_new_contigs($ref, $contig_start, $contig_end, \@range, $reads);
}

#
#   New version, using overlapping sequences that perfectly match.
#
sub add_to_graph {
    my ($graph, $reads, @indexes) = @_;
    for my $i (0 .. $#indexes) {
	my $ii = $indexes[$i];
	my $rd = $reads->[$ii];
	my ($start1, $end1) = @{$reads->[$ii]};
	if (!defined $graph->{nodes}{$rd}) {
	    my $cur_haplo = compressed_seq(query_seq($reads->[$ii]));
	    $graph->{nodes}{$rd} = [ $start1, $end1, \$cur_haplo, $rd ];
	}
	for my $j (0 .. $#indexes) {
	    my $jj = $indexes[$j];
	    next if $ii == $jj;
	    my ($start2, $end2) = @{$reads->[$jj]};
	    next if $start2 < $start1;
	    my $ov_start = max($start1, $start2);
	    my $ov_end = min($end1, $end2);
	    my $ov_len = ($ov_end - $ov_start + 1);
	    next if $ov_len < 1;
	    my @match = matches($ov_start, $ov_end, $reads->[$ii], $reads->[$jj]);
	    next if @match != 2;
	    my $rd_j = $reads->[$jj];
	    $graph->{$rd}{$rd_j} = \@match;
	}
    }
}

##############################################################################
#
#	See if the two sequences match perfectly if compressed.
#
##############################################################################

sub matches {
    my ($rs, $re, @reads) = @_;
    my (@seq, @last, @s, @e, @s_diff, @e_diff);
    for my $i (0, 1) {
	$seq[$i] = query_seq($reads[$i]);
	$last[$i] = length($seq[$i]) - 1;	# maximum for $e[$i]
	($s[$i], $e[$i]) = ref_to_query($reads[$i], $rs, $re);
	die "end $e[$i] > max $last[$i]" if $e[$i] > $last[$i];
    }
    if ($s[0] != 0 || $s[1] != 0) {
	my $a = substr($seq[0], 0, $s[0] + 1);
	my @a = partition_seq($a);
	my $b = substr($seq[1], 0, $s[1] + 1);
	my @b = partition_seq($b);
	my $len = min(scalar @a, scalar @b);
	@a = splice(@a, -$len);
	@b = splice(@b, -$len);
	$s[0] -= length(join('', @a)) - 1;
	$s[1] -= length(join('', @b)) - 1;
    }
    return undef if $s[1] != 0;
    if ($e[0] != $last[0] || $e[1] != $last[1]) {
	my $a = substr($seq[0], $e[0]);
	my @a = partition_seq($a);
	my $b = substr($seq[1], $e[1]);
	my @b = partition_seq($b);
	my $len = min(scalar @a, scalar @b);
	@a = splice(@a, 0, $len);
	@b = splice(@b, 0, $len);
	$e[0] += length(join('', @a)) - 1;
	$e[1] += length(join('', @b)) - 1;
    }
    die "huh? e @e last @last" if ($e[0] != $last[0] && $e[1] != $last[1]);
    my @len = ($e[0] - $s[0] + 1, $e[1] - $s[1] + 1);
    return undef if $len[0] < $min_overlap or $len[1] < $min_overlap;
    my $shrinking = ($e[0] != $last[0]);
    my $a = substr($seq[0], $s[0], $len[0]);
    my $b = substr($seq[1], $s[1], $len[1]);
    my $yes = (compressed_seq($a) eq compressed_seq($b));
# warn "\n$reads[0]->[ID] matches $reads[1]->[ID] ? [$yes]\n";
    return undef if ! $yes;
    return (length(compressed_seq(substr($seq[0], 0, $s[0]))), $shrinking);
}

#
#   Don't compress N's
#
sub partition_seq {
    my ($s) = @_;
    die "bad char in [$s]" if $s !~ /^[ACGTN]*$/i;
    return grep(/./, split /(A+|C+|G+|T+|.)/i, $s);
}

#
#   Don't compress N's
#
sub compressed_seq {
    my ($seq) = @_;
    $seq =~ s/A+/A/gi;
    $seq =~ s/C+/C/gi;
    $seq =~ s/G+/G/gi;
    $seq =~ s/T+/T/gi;
    return $seq;
}

sub get_regex {
    my ($s) = @_;
    die "bad char in [$s]" if $s !~ /^[ACGTN]*$/i;
    my @a = split /(A+|C+|G+|T+)/i, $s;
    my $regex;
    for my $a (@a) {
	my $len = length($a);
	next if $len == 0;
	if ($len == 1) {
	    $regex .= $a;
	}
	elsif ($len == 2) {	# 2 and 3 ok
	    $regex .= sprintf "%s{%d,%d}", substr($a, 0, 1), $len, $len + 1;
	}
	else {
	    $regex .= sprintf "%s{%d,%d}", substr($a, 0, 1), $len - 1, $len + 1;
	}
    }
    return $regex;
}

#
#   Return the original query sequence (in reference orientation).
#
sub query_seq {
    my ($read) = @_;
    my $seq = $fasta->get_seq($read->[ID]);
    $seq = rc($seq) if $read->[STRAND] eq '-';
    return $seq;
}

sub trimmed_seqs {
    my ($read) = @_;
    my $seq = query_seq($read);
    (my $left_trim = substr($seq, 0, $read->[R_TRIM1])) =~ tr/ACGTNacgtn/1234512345/;
    (my $right_trim = substr($seq, -$read->[R_TRIM2])) =~ tr/ACGTNacgtn/1234512345/ if $read->[R_TRIM2] > 0;
    return ($left_trim, $right_trim);
}

#
#   Get alignment array relative to start/end in reference.
#
sub get_complete_align {
    my ($read) = @_;
    my $seq = $read->[ALIGN];
    my $rstart = $read->[START];
    my $rend = $read->[END];
    my ($ltrim, $rtrim) = trimmed_seqs($read);
    $seq = $ltrim . $seq . $rtrim;
    my @a = (split /([A-Za-z ])/, $seq);
    grep(tr/12345/ACGTN/, @a);
    return @a;
}

#
#   Find the query positions that match the reference positions.
#   Query positions are 0-based.
#
sub ref_to_query {
    my ($read, $start, $end) = @_;
    my ($seq, $rstart, $rend, $extra, $array) = @{$read}[ALIGN, START, END, R_TRIM1, R_ARRAY];
    die "start < rstart" if $start < $rstart;
    die "end > rend" if $end > $rend;
    my $ll = ($start - $rstart) * 2;
    my $rr = ($end - $rstart) * 2;
    if (@$array == 0) {
	my @a = split /([Mm ])/, $seq;
	$array = \@a;
	$read->[R_ARRAY] = $array;
    }
    my $before = join('', @{$array}[0 .. $ll]);
    my $spaces1 = ($before =~ tr/ //);
    $before = length($before) - $spaces1;
    my $last = join('', @{$array}[0 .. $rr]);
    my $spaces2 = ($last =~ tr/ //);
    $last = length($last) - $spaces2;
# my $len = length(query_seq($read));
# printf STDERR "full $rstart-$rend want $start-$end returning %d-%d len $len\n", $extra + $before, $extra + $last;
    return ($extra + $before, $extra + $last);
}

#
#
#
sub trim {
    my $side = shift @_;
    my $num = shift @_;
    my $query_trimmed = 0;
    $_[0] = reverse $_[0] if $side eq 'right';
    my $pos = 0;
    for (my $i = 1; $i <= $num; $i++) {
	while (1) {
	    my $a = substr($_[0], $pos++, 1);
	    if ($a =~ /^i$/) {
		$query_trimmed++;
	    }
	    elsif ($a =~ /^M$/i) {
		$query_trimmed++;
		last;
	    }
	    else {
		last;
	    }
	}
    }
    $_[0] = substr($_[0], $pos);
    $_[0] = reverse $_[0] if $side eq 'right';
    return $query_trimmed;
}

sub get_read_ranges4 {
    my ($ranges) = @_;
    my $last_str;
    my @range = @$ranges;
    range4_merge(\@range);
    while (1) {
	my $graph = build_graph(\@range);
	my %done;
	traverse($graph, \%done, keys %{$graph->{nodes}});
	@range = values %done;
	undef %done;
	my $before = range4_to_string(\@range);
warn "after traversal: $before\n" if $debug >= 2;
	range4_merge(\@range);
	my $str = range4_to_string(\@range);
warn "after merge: $str\n" if $debug >= 2;
	if ($last_str eq $str) {
	    return \@range;
	}
	$last_str = $str;
    }
}


sub traverse2 {
    my ($graph, $done, $shrinking, @nodes) = @_;
    for my $node (@nodes) {
	next if $done->{$node};
	$done->{$node} = "doing";
	my ($cs, $ce, $cseq_ref, $cread) = @{$graph->{nodes}{$node}};
	my $cid = $cread->[ID];
	warn "traversing $cid : $$cseq_ref\n" if $debug >= 2;
	die "cread it is null" if $cid eq '';
	my @new_haps;
	for my $r (keys %{$graph->{$node}}) {
	    my $r_done = $done->{$r};
	    next if $r_done eq 'doing';
	    my ($offset, $shrink_link) = @{$graph->{$node}{$r}};
	    next if $shrinking && ! $shrink_link; # FIX is it really needed?
	    if (!$r_done) {
		traverse2($graph, $done, $shrinking || $shrink_link, $r);
		$r_done = $done->{$r};
	    }
	    die "bad offset [$offset]" if $offset eq '' or $offset < 0;
	    for my $next (@$r_done) {
		my ($rs, $re, $rseq, $nodes_ref) = @$next;
		my $old = substr($$cseq_ref, $offset, length($rseq));
		my $new = substr($rseq, 0, length($old));
		if ($old ne $new) { # elongated clump no longer matches our read
		    my $rd = $graph->{nodes}{$r}[N_READ];
		    warn "$cid no longer matches $rd->[ID] at offset $offset\n" if $debug >= 2;
		    warn "old $old vs\nnew $new\n" if $debug >= 2;
		    next;
		}
		my $cur_haplo = substr($$cseq_ref, 0, $offset) . $rseq . substr($$cseq_ref, length($rseq) + $offset);
		my %nodes;
		for my $v (values %$nodes_ref) {
		    # $v = [ $rd, seq, offset ]
		    my ($rd, $seq, $off) = @$v;
		    $off += $offset;
		    $nodes{$rd} = [ $rd, $seq, $off ];
		    die "huh? id is blank for rd [$rd]" if $rd->[ID] eq '';
		}
		die "huh?" if $nodes{$cread};
		die "huh? cread id is blank" if $cread->[ID] eq '';
		$nodes{$cread} = [ $cread, $$cseq_ref, 0 ];
		push(@new_haps, [ $cs, $re, $cur_haplo, \%nodes ]);
verify_clumps([ [ $cs, $re, $cur_haplo, \%nodes ] ]);
	    }
	}
	if (@new_haps) {
	    @new_haps = reduce_clumps(1, @new_haps);
	    die "huh?" if ! @new_haps;
	    $done->{$node} = \@new_haps;
	}
	else {
	    my $hash = { $cread => [ $cread, $$cseq_ref, 0 ] };
	    $done->{$node} = [ [ $cs, $ce, $$cseq_ref, $hash ] ];
verify_clumps($done->{$node});
	}
    }
}

##############################################################################
#
#	Uncompress clumps of reads and split into separate haplotypes if
#	statistics support more than one haplotype in region.
#
##############################################################################

sub clumps_to_haplotypes {
    my (@clumps) = @_;
    my @result;
    warn "clumps_to_haplotypes:\n" if $debug;
    @clumps = sort {
	$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1];
    } @clumps;
verify_clumps(\@clumps); # ZZZ
print_clump(\@clumps) if $debug; # ZZZ
    for my $hap (@clumps) {
verify_clumps([ $hap ]); # ZZZ
	my @vals;
	my ($s, $e, $str, $hash) = @{$hap}[H_START, H_END, H_STR, H_HASH];
	warn "\ndoing clump $s - $e\n" if $debug;
	printf STDERR "    expect: %s\n", uc($str) if $debug;
	my %new_hash;
	my @values = sort {
	    $a->[2] <=> $b->[2] || $a->[1] <=> $b->[1];
	} values %$hash;
	for my $val (@values) {
	    my ($rd, $cstr, $off) = @$val;
	    die "blank id" if $rd->[ID] eq '';
	    die "blank offset" if $off eq '';
	    my @parts = partition_seq(query_seq($rd));
printf STDERR "    doing %d to %d\n", $off, $off + $#parts;
	    for my $i (0 .. $#parts) {
		die "empty part [$parts[$i]]" if $parts[$i] eq '';
		push(@{$vals[$off + $i]}, $parts[$i]);
	    }
	    my $id = $rd->[ID];
	    my $len = @parts;
warn "  id $id off $off len $len\t$cstr\n" if $debug;
warn "  id $id off $off len $len\t@parts\n" if $debug;
	    $new_hash{$rd} = [ $rd, \@parts, $off ];
	}
	my @new_str;
	for my $i (0 .. $#vals) {
	    my $expected = uc(substr($str, $i, 1));
	    my @col = @{$vals[$i]};
	    die "huh? empty col $i, expected [$expected]\n" if @col == 0;
	    my $sum = 0;
	    my $val;
	    for my $c (@col) {
		$sum += length($c);
		my $v = substr("\U$c", 0, 1);
		$val = $v if ! defined $val;
		die "$v ne $val, expected [$expected] at col $i" if $v ne $val;
	    }
	    my $num = int(($sum / @col) + .5);
	    $val = $val x $num;
printf STDERR "    $i @col str [%s] -> $val sum $sum num $num\n", substr($str, $i, 1);
	    push(@new_str, $val);
	}
	push(@result, [ $s, $e, \@new_str, \%new_hash ]);
    }
    return @result;
}

sub merge_similar_haplotypes {
    my ($graph, @new_haps) = @_;
    return @new_haps;
}

sub reduce_clumps {
    my ($strict, @new_haps) = @_;

    @new_haps = sort {
	$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1];
    } @new_haps;
    printf STDERR "\nreduce_clumps: %d haplotypes before, debug [$debug]\n", scalar @new_haps if $debug >= 2;
    print_clump(\@new_haps) if $debug >= 2;
    # verify_clumps(\@new_haps);

    # remove substring haplotypes
    my $did = 1;
    while (@new_haps && $did) {
	$did = 0;
	for (my $i = 0; $i < @new_haps; $i++) {
	    my $str_i = $new_haps[$i]->[H_STR];
	    my $hash_i = $new_haps[$i]->[H_HASH];
	    for (my $j = 0; $j < @new_haps; $j++) {
		next if $i == $j;
		my $str_j = $new_haps[$j]->[H_STR];
		next if length($str_i) > length($str_j);
		my $hash_j = $new_haps[$j]->[H_HASH];
		$str_i = "^$str_i" if $strict;
		if ($str_j =~ /$str_i/i) {
		    my $offset = length($`);
		    while (my ($k, $v) = each %$hash_i) {
			my ($rd, $seq, $off) = @$v;
			$hash_j->{$k} = [ $rd, $seq, $offset + $off ] if ! defined $hash_j->{$k};
		    }
		    splice(@new_haps, $i, 1);
		    $did = 1;
		    $i--;
		    last;
		}
	    }
	}
    }

    # remove completely-enclosed seqs, but not of same length
    $did = 1;
    while (@new_haps && $did) {
	$did = 0;
	for (my $i = 0; $i < @new_haps; $i++) {
	    my @pos_i = (@{$new_haps[$i]})[H_START, H_END];
	    for (my $j = 0; $j < @new_haps; $j++) {
		next if $i == $j;
		my @pos_j = (@{$new_haps[$j]})[H_START, H_END];
		if (($pos_i[0] >= $pos_j[0] && $pos_i[1] < $pos_j[1]) ||
		    ($pos_i[0] > $pos_j[0] && $pos_i[1] <= $pos_j[1])) {
		    splice(@new_haps, $i, 1);
		    $did = 1;
		    $i--;
		    last;
		}
	    }
	}
    }

    # remove furthest haplotypes among siblings of equal size
    $did = 1;
    while (@new_haps && $did) {
	$did = 0;
	for (my $i = 0; $i < @new_haps; $i++) {
	    my @pos_i = (@{$new_haps[$i]})[H_START, H_END];
	    my $i_badness = badness($new_haps[$i]);
	    for (my $j = 0; $j < @new_haps; $j++) {
		next if $i == $j;
		my @pos_j = (@{$new_haps[$j]})[H_START, H_END];
		next if $pos_i[0] != $pos_j[0] || $pos_i[1] != $pos_j[1];
		my $j_badness = badness($new_haps[$j]);
		if ($i_badness >= $j_badness) {
# warn "removing random sibling because badness() not finished\n"; # ZZZ
		    splice(@new_haps, $i, 1);
		    $did = 1;
		    $i--;
		    last;
		}
	    }
	}
    }

    if (!$strict) {
	# remove haplotypes that are mostly enclosed
	my $did = 1;
	while (@new_haps && $did) {
	    $did = 0;
	    for (my $i = 0; $i < @new_haps; $i++) {
		my @pos_i = (@{$new_haps[$i]})[H_START, H_END];
		for (my $j = 0; $j < @new_haps; $j++) {
		    next if $i == $j;
		    my @pos_j = (@{$new_haps[$j]})[H_START, H_END];
		    next if ($pos_i[1] - $pos_i[0]) >= ($pos_j[1] - $pos_j[0]);
		    my $ov_start = max($pos_i[0], $pos_j[0]);
		    my $ov_end = min($pos_i[1], $pos_j[1]);
		    my $ov_len = ($ov_end - $ov_start + 1);
		    if ($ov_len / ($pos_i[1] - $pos_i[0] + 1) >= $overlap_percent / 100) {
			splice(@new_haps, $i, 1);
			$did = 1;
			$i--;
			last;
		    }
		}
	    }
	}
    }

printf STDERR "%d haplotypes after\n", scalar @new_haps if $debug >= 2;
print_clump(\@new_haps) if $debug >= 2;
verify_clumps(\@new_haps); #ZZZ

    return @new_haps;
}

sub badness {
    return 10; # FIX ZZZ YYY
}


#
#   Amount of trim determines ...
#
sub add_read_plus_overlaps2 {
    my ($ranges, $read) = @_;
    my ($start, $end, $id, $score, $trim1, $trim2) = @$read;
    my ($left_overlap, $right_overlap);
    if ($trim1 > $max_gap) { # left only
	$left_overlap = $contig_overlap;
    }
    else {
	$left_overlap = $contig_hash->{$id} ? $big_overlap : $min_overlap;
    }
    if ($trim2 > $max_gap) { # left only
	$right_overlap = $contig_overlap;
    }
    else {
	$right_overlap = $contig_hash->{$id} ? $big_overlap : $min_overlap;
    }
    warn "adding marker $start, $end, $left_overlap, $right_overlap\n" if $debug >= 3;
    my $a = [$start, $end, $left_overlap, $right_overlap, $read];
    push(@$ranges, $a);
}

sub print_clump {
    my ($clump, $align) = @_;
    for my $r (@$clump) {
	my ($cs, $ce, $seq_ref, $reads) = @$r;
	warn "    [$cs, $ce]\n";
	printf STDERR "    $$seq_ref\n";
	my @values = sort { $a->[2] <=> $b->[2] } values %$reads;
	for my $v (@values) {
	    my ($rd, $seq_ref, $offset) = @$v;
	    if (1 or $align) {
		my $space = ' ' x $offset;
		printf STDERR "    $space$seq_ref id $rd->[ID] offset $offset\n";
	    }
	    else {
		printf STDERR "    id $rd->[ID] offset $offset\n";
	    }
	}
	warn "\n";
    }
}

sub verify_clumps {
    my ($clumps) = @_;
    for my $r (@$clumps) {
	my ($cs, $ce, $seq, $reads) = @$r;
	for my $v (values %$reads) {
	    my ($rd, $rd_seq, $offset) = @$v;
	    my $expect = substr($seq, $offset, length($rd_seq));
	    if (uc($expect) ne uc($rd_seq)) {
		my $space = ' ' x $offset;
		printf STDERR "verify_clump failed for [$cs, $ce] str_len %d $seq\n", length($seq);
		printf STDERR "    rd offset $offset len %d and %d\n", length($rd_seq), length($expect);
		printf STDERR "    $seq\n";
		printf STDERR "    $space$rd_seq id $rd->[ID] offset $offset\n";
		confess "bye";
	    }
	}
    }
}

sub print_haplotypes {
    my ($range) = @_;
    @$range = sort {
	$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1];
    } @$range;
    my $count = 0;
    for my $r (@$range) {
	my ($cs, $ce, $seq_ref, $reads) = @$r;
	my $seq = join('', @$seq_ref);
	my $len = length($seq);
	warn "    [$count] ref:[$cs, $ce] len $len $seq\n";
print ">$count $cs-$ce\n$seq\n"; # ZZZ
	my @reads = sort {
	    $a->[2] <=> $b->[2];
	} values %$reads;
	for my $v (@reads) {
	    my ($rd, $parts_ref, $offset) = @$v;
	    # my $space = ' ' x $offset;
	    # printf STDERR "    $space$seq_ref id $k->[ID] offset $offset\n";
	    my $len = @$parts_ref;
	    printf STDERR "      id $rd->[ID] offset $offset len $len\n" if $debug >= 2;
	}
	# warn "\n";
	$count++;
    }
}

sub print_range4 {
    my ($range) = @_;
    my @range = sort {
	$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1];
    } @$range;
    for my $r (@range) {
	warn "    @{$r}[0, 1]\n";
    }
}

sub range4_to_string {
    my @list;
    for my $r (@{$_[0]}) {
	push(@list, "[@$r]");
    }
    return join(' ', sort @list);
}

sub print_graph {
    my ($graph) = @_;
    warn "\nbuild_graph done, graph nodes:\n";
    for my $node (sort { $a->[0] <=> $b->[0] } values %{$graph->{nodes}}) {
	my $rd = $node->[3];
	printf STDERR "    $rd->[ID]: @$node\n";
    }
    warn "\ngraph edges:\n";
    for my $first (sort { $a->[0] <=> $b->[0] } values %{$graph->{nodes}}) {
	my $rd = $first->[3];
	printf STDERR "    $rd->[ID]: [@$first] ->\n";
	my @keys = keys %{$graph->{$rd}};
	for my $second (sort { $graph->{$rd}->{$a}->[0] <=> $graph->{$rd}->{$b}->[0] } @keys) {
	    my $node = $graph->{nodes}->{$second};
	    my $edge = $graph->{$rd}{$second};
	    my $rd = $node->[3];
	    printf STDERR "        -> $rd->[ID]: [@$node] <@$edge>\n";
	}
    }
}

##############################################################################
#
#	Build Contig from ContigLayout
#
##############################################################################

sub Contig::build {
    my ($layout_contig) = @_;
    my $ref         = $layout_contig->{ref_name};
    my $ref_fasta   = $layout_contig->{ref_fasta};
    my $contig_name = $layout_contig->{contig_name};
    my $reads       = $layout_contig->{reads};
    my $contig_class = { }; bless $contig_class, Contig;
    my $contig_start = $layout_contig->{contig_start};
    my $contig_end = $layout_contig->{contig_end};
    $contig_class->{name} = $contig_name;
    printf STDERR "build_contig $ref/$contig_name $contig_start-$contig_end, %d reads\n", scalar @$reads if $debug;
    my $ref_seq = $ref_fasta->get_seq($ref) if $ref_fasta;
    my @len;
    warn "    building matrix\n" if $debug;
    for my $read (@$reads) {
	my @a = get_complete_align($read);
	my $j = $read->[START] * 2;
	for my $i (0 .. $#a) {
	    my $len = length($a[$i]);
	    $len[$j] = $len if $len[$j] < $len;
	    $j++;
	}
    }
    if ($ref_fasta) {
	for my $i (0 .. length($ref_seq) - 1) {
	    my $base = substr($ref_seq, $i, 1);
	    my $j = $i * 2 + 1;
	    $len[$j] = 1 if $len[$j] < 1;
	}
    }
    my $len = 0;  grep($len += $_, @len);
    $contig_class->{qual} = "l" x $len;

    my ($seq, @map);
    if ($ref_fasta) {
	my $pos = 0;
	for my $i (0 .. $#len) {
	    $map[$i] = length($seq);
	    my $key = ($i % 2 == 0) ? '' : substr($ref_seq, $pos++, 1);
	    $seq .= "-" x ($len[$i] - length($key)) . $key;
	}
    }
    $contig_class->{seq} = $seq;

    my @reads;
    for my $read (@$reads) {
	my @a = get_complete_align($read);		# FIX - could be slow
	my $seq_len = length(query_seq($read));		# FIX - could be slow
	my ($s, $e) = (0, $seq_len);
	($s, $e) = ($e, $s) if $read->[STRAND] =~ /^-/;
	#
	# calculate gaps
	#
	my $gaps;
	my $pos = 0;
	my $start = length($a[0]) ? 0 : 1;
	my $j = $read->[START] * 2 + $start;
	for my $i ($start .. $#a - 1) {
	    my $bases = $a[$i];
	    $bases =~ s/ //g;
	    if (length($bases) < $len[$j]) {
		$gaps .= "$pos\n" x ($len[$j] - length($bases));
	    }
	    $pos += length($bases);
	    $j++;
	}
	my $off = $map[2 * $read->[START] + $start];
	my $read = join(' ', $read->[ID], $s, $e, $off, $gaps);
	push(@reads, $read);
    }
    $contig_class->{reads} = \@reads;
    return $contig_class;
}


##############################################################################
#
#	Print Contig in AMOS CTG format
#
##############################################################################

sub Contig::print {
    my $contig = shift;
    my $fd = shift;
    my $contig_name = $contig->{name};
    print $fd "{CTG\neid:$contig_name\niid:$contig_name\nqlt:\n";
    print_wrapped($fd, $contig->{qual}, 70, 1);
    print $fd ".\nseq:\n";
    print_wrapped($fd, $contig->{seq}, 70, 1);
    print $fd ".\n";
    for my $read (@{$contig->{reads}}) {
	print $fd "{TLE\n";
	my ($id, $start, $end, $off, $gaps) = split / /, $read;
	print $fd "clr:$start,$end\n";
	if ($gaps) {
	    print $fd "gap:\n$gaps.\n";
	}
	print $fd "off:$off\n";
	print $fd "src:$id\n";
	print $fd "}\n";
    }
    print $fd "}\n";
}

##############################################################################

sub LayoutContig::build {
    my ($ref_name, $ref_fasta, $contig_name, $contig_start, $contig_end, $reads, $reads_fasta) = @_;
    my $class = { }; bless $class, LayoutContig;
    $class->{ref_name} = $ref_name;
    $class->{ref_fasta} = $ref_fasta;
    $class->{contig_name} = $contig_name;
    $class->{contig_start} = $contig_start;
    $class->{contig_end} = $contig_end;
    $class->{reads} = $reads;
    $class->{reads_fasta} = $reads_fasta;
    return $class;
}


##############################################################################















##############################################################################
#
#	Unused
#
##############################################################################

sub print_contig {
    my ($ref, $contig_start, $contig_end, $reads) = @_;
    my $new_start = 0;
    my $new_end = ($contig_end - $contig_start);
    my $num_kept = @$reads;
    next if $num_kept == 0;
    $num_contigs++;
    print "C $num_contigs\t$num_kept\t$ref\t$contig_start-$contig_end\n";
    warn "C $num_contigs\t$num_kept\t$ref\t$contig_start-$contig_end\n";
    @$reads = sort {
	$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] || $a->[2] <=> $b->[2];
    } @$reads;
    for my $read (@$reads) {
	my ($start, $end, $id, $score, $trim1, $trim2, $strand, $seq) = @$read;
	if ($start < $new_start) {
	    my $diff = $new_start - $start;
	    $diff = trim('left', $diff, $seq);
	    $trim1 += $diff;
	    $start = $new_start;
	}
	if ($end > $new_end) {
	    my $diff = $end - $new_end;
	    $diff = trim('right', $diff, $seq);
	    $trim2 += $diff;
	    $end = $new_end;
	}
	next if ($end - $start + 1) <= 10;
	if ($strand ne '+') {
	    ($start, $end) = ($end, $start);
	}
	if ($opt_r) {
	    print "$id $start $end\t$trim1\t$trim2\t$score\n";
	}
	else {
	    print "$id $start $end\t$trim1\t$trim2\t$score\t$seq\n";
	}
    }
    print "\n";
}

sub covered {
    my ($kept_reads, $index, @all_indexes) = @_;
    my ($start, $end, $id, $score, $trim1, $trim2) = @{$kept_reads->{$index}};

    my @saved = ($big_overlap, $contig_overlap);
    ($big_overlap, $contig_overlap) = ($big_num, $big_num);

    my @range;
warn "\ndoing covered $start-$end [$id] $trim1 $trim2\n" if $debug >= 2;
warn "neighbor reads:\n" if $debug >= 2;
    for my $i (@all_indexes) {
	next if $i == $index;
	my ($s, $e, $id, $score, $trim1, $trim2) = @{$kept_reads->{$i}};
warn "    $s-$e [$id] $trim1 $trim2\n" if $debug >= 2;
        add_read_plus_overlaps2(\@range, $s, $e, $id, $trim1, $trim2);
    }
    range4_merge(\@range);
warn "raw range without:\n" if $debug >= 2;
print_range4(\@range) if $debug >= 2;
    my $final_range = get_read_ranges4(\@range);
    my $without = range4_to_string($final_range);
warn "range without: $without\n" if $debug >= 2;

    add_read_plus_overlaps2(\@range, $start, $end, $id, $trim1, $trim2);
    range4_merge(\@range);
warn "raw range with:\n" if $debug >= 2;
print_range4(\@range) if $debug >= 2;
    $final_range = get_read_ranges4(\@range);
    my $with = range4_to_string($final_range);
warn "range with: $with\n" if $debug >= 2;
    $with = "$with";

    my $range2 = range4_to_range2($final_range);
    my $tmp = range_intersect([ $start, $end ], $range2);
    range_simplify($tmp);
    warn "intersected range with: @$tmp\n" if $debug >= 2;
    warn "wo $without vs w $with vs read $start $end\n\n" if $debug >= 2;
    die "@$tmp != $start $end for id $id" if $tmp->[0] != $start or $tmp->[1] != $end;

    ($big_overlap, $contig_overlap) = @saved;
    return ($with, $without);
}

#
#   Calculate best score, don't penalize partial alignments.
#
sub get_score1 {
    my ($read) = @_;
    my ($start, $end, $id, $score, $t1, $t2, $strand, $seq) = @$read;
    confess "no seq" if $seq eq '';
    my $cut_left = ($t1 > $max_gap);
    my $cut_right = ($t2 > $max_gap);
    my $end_cut = 0;
    $end_cut += $t1 if $cut_left;
    $end_cut += $t2 if $cut_right;
    my $gap = 0;
    $seq =~ s/^[0-9]+//;
    $seq =~ s/[0-9]+$//;
    while ($seq =~ / +|[0-9]+/g) {
	$gap = max($gap, length($&));
    }
    if ($end_cut) {
	my @counts;
	my $match = $seq =~ tr/[A-Z]/[A-Z]/s;
	my $mismatch = $seq =~ tr/[a-z]/[a-z]/s;
	my $inserts = $seq =~ tr/[0-9]/[0-9]/s;
	my $qgap = $seq =~ tr/ / /s;
	my $qlen = $match + $mismatch + $inserts;
	my $qsize = $t1 + $t2 + $qlen;
	$score = $match / ($qsize + $qgap - $end_cut) * 100;
	return ($score, $gap);
    }
    return ($score, $gap);
}

sub get_score2 {
    my ($read) = @_;
    my ($start, $end, $id, $score, $t1, $t2, $strand, $seq, $index) = @$read;
    my ($igap, $egap) = (0, 0, 0);
    $egap = max($egap, $t1);
    $egap = max($egap, $t2);
    while ($seq =~ / +|[0-9]+/g) {
	$igap = max($igap, length($&));
    }
    return ($score, $egap, $igap);
}

sub recalc_score {
    my ($read) = @_;
    my $seq_ref = \$read->[7];
    my ($start, $end, $id, $score, $t1, $t2, $strand) = @$read;
    confess "no seq for @$read" if $$seq_ref eq '';

    my $match = $$seq_ref =~ tr/[A-Z]/[A-Z]/;
    my $qgap = $$seq_ref =~ tr/ / /;
    my $mismatch = $$seq_ref =~ tr/[a-z]/[a-z]/;
    my $inserts = $$seq_ref =~ tr/[0-9]/[0-9]/;
    my $qlen = $match + $mismatch + $inserts;

    my $qsize = $t1 + $t2 + $qlen;
    warn "    recalc_score id $id qsize ($qsize) = $t1 + $t2 + $qlen; seq $$seq_ref\n" if $debug >= 3;
    $score = $match / ($qsize + $qgap) * 100;
    $read->[3] = $score;
}

sub remove_low_scores_1 {
    my ($ref, $contig_start, $contig_end, $reads) = @_;
    warn "    remove_low_scores_1($ref, $contig_start, $contig_end)\n" if $debug;
    printf STDERR "    starting with %d reads\n", scalar @$reads if $debug;
    my $removed = 0;
    for (my $i = 0; $i <= $#{$reads}; $i++) {
	my $read = $reads->[$i];
	my ($start, $end, $id, $orig_score, $trim1, $trim2, $strand) = @$read;
	my ($score, $gap) = get_score1($read);
	if ($score < $min_score or $gap > $max_igap or ($end - $start + 1) < $min_fragment) {
	    warn "    removing id $id [$start-$end] [trim $trim1 $trim2] score $score gap $gap\n" if $debug >= 3;
	    splice(@$reads, $i, 1);
	    $i--;
	    $removed++;
	}
    }
    warn "    removed $removed reads\n" if $debug;
}

#
#   For each subrange create contig and list of reads with relative offsets
#
sub get_new_contigs {
    my ($ref, $contig_start, $contig_end, $range, $used_reads) = @_;
    printf STDERR "\nget_new_contigs($ref, $contig_start, $contig_end])\n" if $debug;
    printf STDERR "    starting with %d reads\n", scalar @$used_reads if $debug;
    my $m = markers::new(700);
    my %kept_reads;
    my $index = 0;
    for my $read (@$used_reads) {
        my ($start, $end, $id, $score, $trim1, $trim2) = @$read;
	my $new_index = $m->add_marker('contig', "+", $start, $end); # only store position
	die "index mismatch" if $index != $new_index;
	$index++;
    }
    my @contigs;
    for (my $i = 0; $i < $#{$range}; $i += 2) {
        my ($new_start, $new_end) = @{$range}[$i, $i + 1];
	printf STDERR "making contig for range $new_start - $new_end (size %d)\n", $new_end - $new_start + 1 if $debug;
	die "bad range ($new_start, $new_end)" if $new_start eq '' or $new_end eq '';
	my @indexes = $m->get_covering_marker_indexes($min_fragment, 'contig', "+", $new_start, $new_end);
	printf STDERR "    got %d overlapping reads\n", scalar @indexes;
	my @reads;
	for my $i (@indexes) {
	    push(@reads, $used_reads->[$i]);
	}
	printf STDERR "    pushed %d reads\n", scalar @indexes;
	@reads = sort {
	    $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1];
	} @reads;
	printf STDERR "    sorted %d reads\n", scalar @indexes;
	my $num_kept = @reads;
	my $offset1 = $new_start;
	my $c_start = $contig_start + $offset1;
	my $c_end = $c_start + ($new_end - $new_start);
	my @contig_reads = ();
	my @contig = ($ref, $c_start, $c_end, \@contig_reads);
	push(@contigs, \@contig);
	printf STDERR "    building %d reads\n", scalar @indexes;
	my $trimmed = 0;
	while (my $read = shift @reads) {
	    my ($start, $end, $id, $score, $trim1, $trim2, $strand, $seq) = @$read;
	    confess "seq is null! [@$read]" if $seq eq '';
	    if ($start < $new_start) {
		my $diff = $new_start - $start;
		$diff = trim('left', $diff, $seq);
		$trim1 += $diff;
		$start = $new_start;
		$trimmed++;
	    }
	    if ($end > $new_end) {
		my $diff = $end - $new_end;
		$diff = trim('right', $diff, $seq);
		$trim2 += $diff;
		$end = $new_end;
		$trimmed++;
	    }
	    $start -= $offset1;
	    $end -= $offset1;
	    my $read = [$start, $end, $id, $score, $trim1, $trim2, $strand, $seq];
	    recalc_score($read);
	    push(@contig_reads, $read);
	}
	warn "    $trimmed reads were trimmed\n";
    }
    @$used_reads = ();
    warn "\n";
    return @contigs;
}

#
#   Remove worst reads
#
#	Round 1: remove reads based on absolute scores
#	Round 2: remove reads based on relative scores
#
sub fix_it {
    my ($ref, $contig_start, $contig_end, $reads, $round) = @_;
    warn "\nfix_it($ref, $contig_start, $contig_end, $round)\n";
    die "no need to call fix_it in round 2 since opt_d is null!" if $opt_d eq '' and $round == 2;
    my $contig_len = $contig_end - $contig_start + 1;
    my $m = markers::new(200, 'hash');
    my (%kept_reads, %scores, %best_reads, %worst_reads);
    my $index = 0;
    printf STDERR "fix_it: getting scores for %d reads\n", scalar @$reads;
    for my $read (@$reads) {
        my ($start, $end, $id, $score, $trim1, $trim2, $strand, $seq) = @$read;
	my ($new_score, $egap, $igap) = get_score2(0, $contig_len, $read);
	if ($round == 1 && $new_score >= $min_score && $egap <= $max_gap && $igap <= $max_igap) {
	    $best_reads{$index} = "$start $end";
	}
	my $new_index = $m->add_marker('contig', "+", $start, $end); # only store position
	die "index mismatch" if $index != $new_index;
	$scores{$index} = $new_score;
	$kept_reads{$index} = $read;
	$index++;
    }

    if ($round == 2) {
	warn "    finding best reads\n";
	for (my $pos = 0; $pos < $contig_len; $pos += $patch) {
	    my @indexes = $m->get_covering_marker_indexes('any', 'contig', "+", $pos, $pos + $patch - 1);
	    my $best_score;
	    for my $index (@indexes) {
		my $score = $scores{$index};
		$best_score = $score if $score > $best_score;
	    }
	    my $worst_allowed = $best_score * (1 - $allow);
	    for my $index (@indexes) {
		my ($start, $end, $id) = @{$kept_reads{$index}};
		my $score = $scores{$index};
		if ($score >= $worst_allowed) { # get_score
		    $best_reads{$index} = "$start $end";
		}
	    }
	}
	printf STDERR "    got %d best reads\n", scalar keys %best_reads;
    }

    warn "    computing good range\n";
    for my $index (keys %kept_reads) {
        my ($start, $end, $id, $score, $trim1, $trim2) = @{$kept_reads{$index}};
	if (!$best_reads{$index}) {
	    my $score = $scores{$index};
	    $worst_reads{$index} = "$start $end $score";
	}
    }

    warn "    sorting worst reads\n";
    my @worst_indexes = sort {
	my @a = split / /, $worst_reads{$a};
	my @b = split / /, $worst_reads{$b};
	$a[2] <=> $b[2];
    } keys %worst_reads;
    printf STDERR "    done sorting %d worst reads\n", scalar @worst_indexes;

    while (@worst_indexes) {
	my $index = shift @worst_indexes;
        my ($start, $end) = @{$kept_reads{$index}};
	my @all_indexes = $m->get_covering_marker_indexes('any', 'contig', "+", $start, $end);
	if ($opt_b eq '' or $round == 1) {
	    my ($covered_with, $covered_without) = covered(\%kept_reads, $index, @all_indexes);
	    if ($covered_with ne $covered_without) {
		next;
	    }
	}
        my ($start, $end, $id, $score, $trim1, $trim2) = @{$kept_reads{$index}};
	warn "    removing $start-$end [$id] score $score trim $trim1 $trim2\n" if $debug >= 1;
	$m->delete_marker($index);
	delete $worst_reads{$index}; # unnecessary
	delete $kept_reads{$index};
    }

    my @used_reads = values %kept_reads;
    my @contigs = get_contigs($ref, $contig_start, $contig_end, \@used_reads);
    if ($opt_b eq '' or $round == 1) {
	die "contig was split! [@contigs]" if @contigs != 1;
	my ($r, $cs, $ce) = @{$contigs[0]};
	if ($cs != $contig_start or $ce != $contig_end) {
	    die "contig has changed! [$contig_start-$contig_end] -> [$cs, $ce]";
	}
    }
    return @contigs;
}




sub reduce_haplotypes {
    my (@haps) = @_;
    my $best;
printf STDERR "\nreduce_haplotypes: %d haplotypes", scalar @haps;
    @haps = sort {
	# order by start, then longest to shortest
	$a->[0] <=> $b->[0] || $b->[1] <=> $a->[1];
    } @haps;
    my @scores;
    my $did_something = 1;
    while ($did_something) {
	$did_something = 0;
	for my $i (0 .. $#haps) {
	    next if ! defined $haps[$i];
	    my ($s1, $e1, $array1, $hash1) = @{$haps[$i]}[H_START, H_END, H_STR, H_HASH];
	    my $seq1 = join('', @$array1);
	    for my $j ($i + 1 .. $#haps) {
		next if ! defined $haps[$j];
		my ($s2, $e2, $array2, $hash2) = @{$haps[$j]}[H_START, H_END, H_STR, H_HASH];
		next if $scores[$i][$j];
		if ($e1 - $s1 + 1 < $min_overlap) {
		    $scores[$i][$j] = [ 1, "" ];
		    next;
		}
		my $seq2 = join('', @$array2);
warn "\n$i vs $j\n";
		my ($score, $consensus) = bioperl_align($seq1, $seq2, 1);
		$scores[$i][$j] = [ $score, $consensus ];
	    }
	}
	my ($best, @indexes);
	for my $i (0 .. $#haps) {
	    for my $j (0 .. $#haps) {
		my $score = $scores[$i][$j][0];
		if ($score > $best) {
		    $best = $score;
		    @indexes = ($i, $j);
		}
	    }
	}
	if ($best >= 95) {
	    my ($i, $j) = @indexes;
	    my ($s1, $e1, $array1, $hash1) = @{$haps[$i]}[H_START, H_END, H_STR, H_HASH];
	    my ($s2, $e2, $array2, $hash2) = @{$haps[$j]}[H_START, H_END, H_STR, H_HASH];
	    $haps[$i][H_START] = min($s1, $s2);
	    $haps[$i][H_END] = max($e1, $e2);
	    my $str = $scores[$i][$j][1];
	    $haps[$i][H_STR] = [ partition_seq($str) ];
printf STDERR "$i [$s1-$e1] %s\n", join('', @$array1);
printf STDERR "$j [$s2-$e2] %s\n", join('', @$array2);
printf STDERR "new [$str]\n";

	    for my $i (0 .. $#haps) {
		for my $j (0 .. $#haps) {
		    undef $scores[$i][$j] if $scores[$i][$j];
		}
	    }
	    undef $haps[$j];
	    $did_something = 1;
	}
    }
    print STDERR "\n   ";
    for my $j (0 .. $#haps) {
	printf STDERR "%5d", $j;
    }
    print STDERR "\n";
    for my $i (0 .. $#haps) {
	printf STDERR "%2d ", $i;
	for my $j (0 .. $#haps) {
	    my $score = $scores[$i][$j][0];
	    printf STDERR "%5.1f", $score;
	}
	warn "\n";
    }
    my @result;
    for my $i (0 .. $#haps) {
	next if ! defined $haps[$i];
	push(@result, $haps[$i]);
    }
    return @result;
}

##############################################################################

use Bio::Tools::dpAlign;
use Bio::SeqIO;
use Bio::AlignIO;
use Bio::Align::DNAStatistics;

sub bioperl_align {
    my ($seq1, $seq2, $debug) = @_;

    my $format = 'pfam';

    $seq1 = Bio::PrimarySeq->new(-seq => $seq1, -id  => 'seq1', -alphabet => 'dna');
    $seq2 = Bio::PrimarySeq->new(-seq => $seq2, -id  => 'seq2', -alphabet => 'dna');
    my $len = min($seq1->length, $seq2->length);

    my $type = Bio::Tools::dpAlign::DPALIGN_ENDSFREE_MILLER_MYERS;
    my $factory = new Bio::Tools::dpAlign(
	-match => 3,
	-mismatch => -3,
	-gap => 1,
	-ext => 3,
	-alg => $type);

    # actually do the alignment
    my $out = $factory->pairwise_alignment($seq1, $seq2);
    my $alnout = new Bio::AlignIO(-format => $format, -fh => \*STDERR);
    my $str = $out->match_line;
printf STDERR "seq1 %s\nseq2 %s\naln  %s\n", $seq1->seq, $seq2->seq, $str if $debug;
    my $match = $str =~ tr/\*/\*/s;
    $alnout->write_aln($out) if $debug;
    my $str = $out->consensus_string;
    return ($match / $len * 100, $str);
}
